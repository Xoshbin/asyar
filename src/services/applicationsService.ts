// src/services/applicationsService.ts
import { openPath } from "@tauri-apps/plugin-opener";
import { invoke } from "@tauri-apps/api/core";
// Remove core invoke if only using searchService or specific invokes like 'hide'
// import * as core from "@tauri-apps/api/core";
import { logService } from "./logService";
import type { AppResult } from "../types";
import type { IApplicationsService } from "./interfaces/IApplicationsService";
// Assuming Application type has 'id', 'name', 'path' from list_applications
import type { Application } from "./search/types/Application"; // Import if needed for type checking
import type { SearchableItem } from "./search/types/SearchableItem";
import { searchService } from "./search/SearchService";
// Import the search service instance

// Helper function to generate object IDs consistently (MUST match Rust logic)
// Use the ID returned by list_applications (which now includes the Rust-generated ID)
const getAppObjectId = (app: {
  id: string; // Expecting the ID generated by Rust via list_applications
  name: string;
  path: string;
}): string => `app_${app.id}`;

class ApplicationsService implements IApplicationsService {
  private initialized = false;
  // Store the full Application object including the ID from list_applications
  private allApps: Application[] = [];

  async init(): Promise<void> {
    if (this.initialized) {
      logService.debug("ApplicationsService already initialized.");
      return;
    }
    logService.info("Initializing ApplicationsService...");
    try {
      // Perform initial sync on startup
      await this.syncApplicationIndex();
      this.initialized = true;
      logService.info("ApplicationsService initialized successfully.");
    } catch (error) {
      logService.error(`Failed to initialize applications service: ${error}`);
      // Decide if initialization failure is critical
    }
    // ... (init logic remains the same) ...
  }

  // Modified syncApplicationIndex
  private async syncApplicationIndex(): Promise<void> {
    logService.info("Starting application index synchronization...");
    try {
      // 1. Get current applications from Rust (now returns Application[])
      const currentApps: Application[] = await invoke("list_applications");
      this.allApps = currentApps; // Store for getAllApplications method

      // Create a map of current apps keyed by their *expected* object ID
      const currentAppMap = new Map<string, Application>();
      currentApps.forEach((app) => {
        // getAppObjectId uses the ID received from list_applications
        currentAppMap.set(getAppObjectId(app), app);
      });
      const currentAppIds = new Set(currentAppMap.keys());

      // 2. Get indexed application IDs from SearchService
      const indexedAppIds = await searchService.getIndexedObjectIds("app_");

      // 3. Compare and find differences
      const itemsToIndex: SearchableItem[] = [];
      const idsToDelete: string[] = [];

      // Find apps to index (in current apps but not in index)
      currentAppMap.forEach((app, objectId) => {
        if (!indexedAppIds.has(objectId)) {
          // Prepare the object matching the Rust SearchableItem::Application variant
          // Send the ID received from list_applications
          itemsToIndex.push({
            category: "application",
            id: app.id, // Use the ID from list_applications
            name: app.name,
            path: app.path,
          });
        }
      });

      // Find IDs to delete (in index but not in current apps)
      indexedAppIds.forEach((indexedId) => {
        if (!currentAppIds.has(indexedId)) {
          idsToDelete.push(indexedId);
        }
      });

      logService.info(
        `Application Sync: ${itemsToIndex.length} items to index, ${idsToDelete.length} items to delete.`
      );

      // 4. Execute indexing and deletion tasks USING SearchService
      const indexPromises = itemsToIndex.map(
        (item) => searchService.indexItem(item) // Delegate to searchService
      );
      const deletePromises = idsToDelete.map(
        (id) => searchService.deleteItem(id) // Delegate to searchService
      );

      // Wait for all operations to complete
      await Promise.all([...indexPromises, ...deletePromises]);

      logService.info("Application index synchronization completed.");
    } catch (error) {
      logService.error(`Failed to synchronize application index: ${error}`);
      throw error;
    }
  }

  async open(app: AppResult): Promise<void> {
    try {
      invoke("hide"); // Hide the launcher window
      logService.info(
        `APPLICATION_OPENED: Application "${app.name}" opened, path: ${app.path}`
      );
      await openPath(app.path);
    } catch (error) {
      logService.error(`Failed to open ${app.name}: ${error}`);
      // Consider removing the retry logic if openPath handles variations
    }
  }

  // Updated to use the stored list which now includes ID
  public async getAllApplications(): Promise<AppResult[]> {
    if (!this.initialized) {
      await this.init();
    }
    // Map the stored full app data to the expected AppResult format
    return this.allApps.map((app) => ({
      // Include id if AppResult needs it
      // id: app.id,
      name: app.name,
      path: app.path,
      score: 0,
    }));
  }
}

export const applicationService: IApplicationsService =
  new ApplicationsService();
